function answer = snr_setup_ant_profile_eval (elev, azim, data)
    % We interpolate one-dimensionally, first 
    % in elevation angle, then in azimuth.
    % (Were the data regularly spaced, we could easily apply 
    % a single two-dimensional interpolation.)
    idx0 = (data.azim == 0);
    idx180 = (data.azim == 180);
    data0 = interp1_fastest(...
        data.elev(idx0), ...
        data.final(idx0), ...
        elev, ...
        'cubic', 'extrap');
    data180 = interp1_fastest(...
        data.elev(idx180), ...
        data.final(idx180), ...
        elev, ...
        'cubic', 'extrap');
    data360 = data0;

    %whos  % DEBUG
    azim = azimuth_range_positive(azim);
    temp = vertcat(...
        rowvec(data0),   ...
        rowvec(data180), ...
        rowvec(data360)  ...
    );
    %parallel_length = @(azim, elev) azim*pi/180 .* cos(elev*pi/180);
    %temp2 = transpose(parallel_length(...
    %       repmat([-180, 0, 180, 360, 540], n, 1), ...
    %       repmat(elev, 1, 5) ...
    %));
    %%power = interp1_fastest([0; 180; 360], temp, azim);
    %power = NaN(n,1);
    %for i=1:n
    %    if isnan(azim(i)),  continue;  end
    %    %power(i) = interp1_fastest([0; 180; 360], temp(:,i), azim(i));
    %    %power(i) = interp1_fastest([0; 180; 360], temp(:,i), azim(i), 'cubic');
    %    power(i) = interp1_fastest(temp2(:,i), temp(:,i), ...
    %        parallel_length(azim(i), elev(i)), 'cubic');
    %end
    answer = interp1n([0; 180; 360], temp, rowvec(azim));
    answer = reshape(answer, size(azim));
end

